# Тестовое задание (Front-end middle / JS + Vue.js)

## О проекте

В работе находится страница референс-лист объектов компании. Сайт будет работать классическим методом на собственной CMS. **Важно: это не SPA/PWA.**

Разработан экспериментальный алгоритм вывода страниц сайта с целью улучшить SEO-оптимизацию: сервер будет отдавать уже частично отрендеренный блок объектов, а также блок `<script>` следом в коде HTML, внутри которого будет переменная с JSON — это копия данных отрендеренных объектов для дальнейшей обработки во Vue. Алгоритм схож с решениями SSR (Server Side Rendering): страница загружается уже с начальными объектами в блоке `#reference`. Но в отличие от традиционного принципа, в котором после запуска скрипта первоначальные данные снова запрашиваются с сервера, у нас скрипт берёт эти данные из переменной в соседнем блоке.

> Для удобства разработки, дальнейшего масштабирования и переиспользования компонентов мы используем методологию БЭМ. Каждый функциональный модуль (блок) реализован отдельным Vue-скриптом, использует свой шаблон, строгую систему именования классов БЭМ, свою CSS. Все модули взаимодействуют между собой через глобальные переменные. Решение, конечно, немного архаичное и трудоёмкое, но того требует специфика дальнейшего масштабирования.

Модуль референс-листа `vue_reference.js` непосредственно взаимодействует с модулем фильтров `vue_filters.js`. Модуль референс-листа в задаче не доделан, он умеет брать первоначальные данные, рендерит их, а также единожды имитирует подгрузку объектов по достижении нижнего края экрана. Фактически же он должен обращаться к API каждый раз по достижении конца списка и догружать объекты из базы, используя параметры `limit`(сколько объектов получить в JSON. В текущей задаче рекомендуется `limit: 10`, именно столько объектов потенциально влезают в один экран) и `offset`(сколько объектов пропустить от конца), а также параметр `tags:[]` который позволяет отфильтровать объекты по тегу на стороне сервера. К сожалению, на данный момент API ещё не готово, поэтому работу API нужно имитировать с выводом деталей запроса к API в консоль (достаточно будет дополнить `getNextObjects()` во `vue_reference.js` объектами и отрезать каждый раз от него, пока массив не закончится).

## Принцип работы

На странице есть 10 последних объектов из базы. Каждый раз по достижении конца списка срабатывает Intersection Observer на блоке `#reference-loader` и догружается по 10 следующих объектов (POST-запрос в формате JSON). Каждый объект имеет собственный массив тегов `[id, id, ...]`. Фильтры на странице работают как фильтрация объектов по одному или по нескольким тегам (принцип AND — отображаемый объект должен иметь все выбранные теги). Модуль фильтра отдаётся в коде страницы в виде пустого контейнера `#filters` + блок `<script>` с переменной `filtersData` + скрипт `vue_filters.js` в конце страницы.

На старте `vue_filters.js` формирует блок фильтров по данным из переменной. В дальнейшем, при выборе пункта фильтра, скрипт `vue_filters.js` взаимодействует с `vue_reference.js` и последний фильтрует список объектов по выбранному тегу. Если достигнут конец фильтрованного списка, `vue_reference.js` должен сделать запрос к API и догрузить новые объекты, используя серверную фильтрацию (сервер в запросе к API принимает параметр `tags: [ id, id, ...]` и выдаёт только объекты с данными тегами). Это важно, т.к. объектов в базе может быть несколько тысяч, а с каким-то редким тегом — два, к тому же второй где-то в самом начале базы. Соответственно, пошаговая фоновая загрузка полного списка объектов будет весьма объёмна и затянет ожидание.

Если пользователь снимает выбор фильтров, `vue_reference.js` должен отобразить обратно все объекты из основного хранилища и продолжать догружать основной поток при достижении конца списка. Для упрощения решения можно не хранить данные, полученные при серверной фильтрации, и не кэшировать подобные запросы.

---

# Задача

1. Доработать модуль референса `vue_reference.js` для динамической подгрузки списка объектов. Сейчас загрузчик срабатывает лишь единожды. Нужно переустанавливать его каждый раз после загрузки новых объектов, пока не получим все объекты.

2. Доработать модуль референса `vue_reference.js` для загрузки фильтрованных объектов. Сейчас модуль фильтрует только основное хранилище. Нужно использовать эти данные как стартовый набор объектов и догружать остальные с сервера, используя серверную фильтрацию. Как уже было обозначено — новые данные можно не хранить, иначе в хранилище образуются «дыры» и алгоритм их заполнения кратно усложнит решение.

## Комментарии к задаче

Формат запроса к серверу:
```json
  {
    "section": "reference",
    "action": "list",
    "limit": "10",
    "offset": "10",
    "tags": ["1", "2"]
  }
```

Ответ сервера:
```json
[
  {
    "id": "400",
    "title": "Агропромышлен&shy;ный холдинг «Великолукский мясокомбинат»",
    "bghex": "#00254F",
    "img": "./img/bg/ref05.jpg",
    "date_created": "2022-10-13 22:16:15",
    "seen": "2633",
    "url": "velikolukskij_myasokombinat",
    "place": "г. Великие Луки, Новгородская обл.",
    "tags": ["1","2"]
  },
  {
    "id": "394",
    "title": "Название объекта",
    "bghex": "#CCFFCC",
    "img": "./img/bg/ref01.jpg",
    "date_created": "2021-09-12 11:16:15",
    "seen": "32",
    "url": "newton_live",
    "place": "г. Город объекта",
    "tags": ["1","2","5"]
  }
]
```
Если данных нет — пустой массив.
