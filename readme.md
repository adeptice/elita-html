### Тестовое задание

---

# Задача

Сделать модуль фильтров: вёрстку (код и собственную `assets/styles/blocks/filters.css`), а также код модуля `vue_filters.js`. Доработать модуль референса `vue_reference.js` для взаимодействия с фильтрами и правильной подгрузкой новых объектов. На данный момент intersection observer работает неверно — блок стоит в конце шаблона и при первой инициализации данных попадает во viewport. Предполагается замена логики работы блока в процессе модификации `vue_reference.js`. Блок должен стать по сути отдельным компонентом `referenceLoader`, работающим по принципу трассирующего объекта — последним объектом в выдаче (со спиннером). При попадании во viewport блок должен инициировать подгрузку следующих объектов, по 10 штук каждый раз. Если в выдаче есть несколько «дыр», каждая из них должна быть закрыта собственным инстансом трассирующего блока `referenceLoader`.

---

## О задаче

В работе находится страница референс-лист объектов компании. Сайт будет работать на собственной CMS. Не PWA. Разработан собственный алгоритм формирования страниц сервером и интерактивности на клиенте. Для хорошей индексации (SEO) сервер будет отдавать уже частично отрендеренный блок объектов (SSR — Server Side Rendering), а также блок `<script>` тут же в коде HTML, внутри которого будет переменная с JSON — это копия данных отрендеренных объектов для дальнейшей обработки в VUE.

Алгоритм типовой для SSR: страница загружается с начальными объектами в блоке #reference, запускаются VUE-скрипты, которые берут значение переменной в качестве первоначальных данных и маунтят вывод в тот же самый отрендеренный блок `#reference`. Так как по факту новая DOM-структура блока получается идентичной существующей, VUE будет использовать уже существующие DOM-элементы и перерисовка будет незаметной. Вся дальнейшая работа на клиенте будет уже непосредственно с VUE-скриптом, обращение за новыми данными из скрипта — по API. Таким же образом на странице работает меню навигации, можно заглянуть туда.

Для удобства разработки, дальнейшего масштабирования и переиспользования компонентов мы используем методологию БЭМ. Каждый модуль выполнен отдельным VUE-скриптом, использует свой шаблон, строгую систему именования классов БЭМ, свою CSS. Все модули взаимодействуют между собой через глобальные переменные.

Модуль референс-листа `vue_reference.js` должен непосредственно взаимодействовать с модулем фильтров `vue_filters.js`. На данном этапе разработки модуль референс-листа пока только берёт первоначальные данные из JSON и рендерит их в DOM, а также имитирует подгрузку объектов по достижении нижнего края экрана (блок с intersection observer в конце списка). Фактически же он должен обращаться к API и догружать объекты из базы, используя параметры `limit`(сколько объектов получить в JSON) и `offset`(сколько пропустить от начала), а также параметр `tags:[]` который зависит от выбранного фильтра. На данный момент API ещё не готово, поэтому работу API нужно имитировать с выводом деталей запроса к API в консоль.

## Принцип работы

На странице есть 10 последних объектов из базы. Каждый раз по достижении конца списка срабатывает intersection observer и догружается по 10 следующих объектов (POST-запрос в формате JSON). Каждый объект имеет собственный массив тэгов `[id_tag, id_tag, ...]`. Фильтры на странице работают как фильтрация объектов по одному или по нескольким тэгам (принцип AND, то есть отображаемый объект должен иметь все отмеченные тэги). Модуль фильтра отдаётся в коде страницы в виде пустого контейнера `#filters` + блок `<script>` с переменной filters c JSON внутри.

На старте `vue_filters.js` должен сформировать блок фильров по данным из переменной. В дальнейшем, при выборе пункта фильтра, скрипт `vue_filters.js` взаимодействует с `vue_reference.js` и последний отсортировывает список объектов по выбранному тегу. Если достигнут конец отсортированого списка, `vue_reference.js` должен сделать запрос к API и догрузить новые 10 объектов, причём обязательно только с соответвующим фильтру тэгом (сервер в запросе к API принимает параметр `tags: [ id_tag, id_tag, ...]` и выдаёт только объекты с данными тэгами). Это важно, т.к. объектов в базе может быть несколько тысяч, а с каким-то редким тэгом — единицы. Соответственно, если грузить весь список объектов и только потом фильтровать — скорость и качество работы на клиенте будет далёкими от идеала. Если пользователь снимает выбор фильтров, `vue_reference.js` должен отобразить обратно все объекты. При этом, логично, случится ситуация, что выведенный список будет иметь «дыры» в данных, т.к. в хранилище после фильтрации данные загружались нелинейно. Нужно эту ситуацию предусмотреть и в промежутках вставить блоки с intersection observer и спиннером, при достижении которых должно происходить заполнение «дыр» запросами по 10 объектов.

## Комментарии к реализации

Вёрстка блока фильтров — просто список всех доступных тэгов с чекбоксами в блоке `#filters` без разделения на группы. Примерный вид можно подсмотреть в [предварительной вёрстке](https://www.elitacompany.ru/preview/) на разрешении меньше 2000px. Вёрстка не является целью тестового задания, оцениваться будет в первую очередь программный функционал, поэтому время можно сэкономить и сделать по-простому. При желании чекбокс можно использовать из `assets/images/icon_checkbox.svg`.

Формат POST-запроса к серверу:
```json
  {
    "section": "reference",
    "action": "list",
    "limit": "10",
    "offset": "10",
    "tags": ["1", "2"]
  }
```

Ответ сервера:
```json
[
  { "id": "1",
    "title": "Агропромышлен&shy;ный холдинг «Великолукский мясокомбинат»",
    "bghex": "#00254F",
    "img": "./img/bg/ref05.jpg",
    "date_created": "2022-10-13 22:16:15",
    "seen": "2633",
    "url": "velikolukskij_myasokombinat",
    "place": "г. Великие Луки, Новгородская обл.",
    "tags": ["1","2"]
  },
  {
    "id": "5",
    "title": "Название объекта",
    "bghex": "#CCFFCC",
    "img": "./img/bg/ref01.jpg",
    "date_created": "2021-09-12 11:16:15",
    "seen": "32",
    "url": "newton_live",
    "place": "г. Город объекта",
    "tags": ["1", "2", "5"]
  } 
]
```
Если данных нет — пустой массив.